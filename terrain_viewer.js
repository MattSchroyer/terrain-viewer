/* eslint no-param-reassign: 0, no-plusplus: 0, camelcase: 0, no-warning-comments: 0 */

const RESIZE_THROTTLE = 200;

let THREE = window.THREE;
let d3 = window.d3;

export default {
  _init() {
    if (!THREE) {
      THREE = window.THREE;
    }
    if (!d3) {
      d3 = window.d3;
    }

    const _ = this.api.imports._;
    const points = this.api.inputState.get(['data', 'points']);
    const pinOptions = this.api.inputState.get('pinOptions').export();

    this.scene = null;
    this.renderer = null;
    this.controls = null;
    this.camera = null;
    this.renderer = null;
    this.maxZ = null;
    this.minZ = null;
    this.camera_rotate = null;
    this.raycaster = null;
    this.mouse = null;
    this.pin = null;

    this.mouseLocationBefore = {};
    this.mouseLocationAfter = {};

    // this.pinData contains one object forf each pin
    // each object has properties for color, position {x,y,z},
    // projectedIds under the pin,
    // and the UUID for the pin group generated by three.js
    // This is oputput directly to the 'pinKeys' output
    // this.pinData is updated in _addPin()
    this.pinData = [];

    // this.numberOfPins is used to generate unique colors for batches of 10 pins
    // the integer is reset after every 10, is not a running total of pins
    this.numberOfPins = 0;

    // this.currentPinIds is a set containing just the projectedIds of all pinned data
    // this makes it easier to just output all pinned data
    // is converted to an array and output 'allPins' in _outputBinnedIds()
    this.currentPinIds = new Set();

    this.currentPinOptions = pinOptions;

    this.terrainData = [];
    this.widthSegments = 0;
    this.heightSegments = 0;
    this.mouseFlag = false;

    this._setScene();

    if (!points.isEmpty().export()) {
      this.data();
    }

    this._throttledOnResize = _.throttle(this._onResize.bind(this), RESIZE_THROTTLE);
    this._boundOnMouseDown = this._onMouseDown.bind(this);
    this._boundOnMouseMove = this._onMouseMove.bind(this);
    this._boundOnMouseUp = this._onMouseUp.bind(this);

    window.addEventListener('resize', this._throttledOnResize, false);
    this.api.layoutElement.addEventListener('mousedown', this._boundOnMouseDown, false);
    this.api.layoutElement.addEventListener('mousemove', this._boundOnMouseMove, false);
    this.api.layoutElement.addEventListener('mouseup', this._boundOnMouseUp, false);
  },

  _destroy() {
    window.removeEventListener('resize', this._throttledOnResize, false);
    this.api.layoutElement.removeEventListener('mousedown', this._boundOnMouseDown, false);
    this.api.layoutElement.removeEventListener('mousemove', this._boundOnMouseMove, false);
    this.api.layoutElement.removeEventListener('mouseup', this._boundOnMouseUp, false);
  },

  getScene() {
    this.api.output('sceneData', this.scene);
  },

  data() {
    this.clearScene();
    this._makeTerrainData();
    this._addPlane();
    this.labelOptions();
  },

  sceneOptions() {
    const { drawAxes } = this.api.inputState.get('sceneOptions').export();
    const scene = this.scene;

    if (drawAxes) {
      const axesHelper = new THREE.AxisHelper(200);
      axesHelper.name = 'myAxesHelper';
      scene.add(axesHelper);
    } else {
      const axesHelper = scene.getObjectByName('myAxesHelper');
      scene.remove(axesHelper);
    }
  },

  terrainOptions() {
    this.clearScene();
    this._makeTerrainData();
    this._addPlane();
    this.labelOptions();
  },

  labelOptions() {
    const labelOptions = this.api.inputState.get('labelOptions').export();
    const scene = this.scene;

    while (scene.getObjectByName('x_axis_label')) {
      const x_axis_label = scene.getObjectByName('x_axis_label');
      scene.remove(x_axis_label);
    }

    while (scene.getObjectByName('y_axis_label')) {
      const y_axis_label = scene.getObjectByName('y_axis_label');
      scene.remove(y_axis_label);
    }

    while (scene.getObjectByName('z_axis_label')) {
      const z_axis_label = scene.getObjectByName('z_axis_label');
      scene.remove(z_axis_label);
    }

    while (scene.getObjectByName('x_value_label')) {
      const x_value_label = scene.getObjectByName('x_value_label');
      scene.remove(x_value_label);
    }

    while (scene.getObjectByName('y_value_label')) {
      const y_value_label = scene.getObjectByName('y_value_label');
      scene.remove(y_value_label);
    }

    while (scene.getObjectByName('outline')) {
      const outline = scene.getObjectByName('outline');
      scene.remove(outline);
    }

    if (labelOptions.drawLabels) {
      this._addAxesLabels();
      if (labelOptions.xValues.length > 0 || labelOptions.xValues.length > 0) {
        this._addValueLabels();
      }
    }

    if (labelOptions.drawOutline) {
      this._drawOutline();
    }
  },

  cameraPosition() {
    const state = this.api.inputState;
    const cameraPosition = state.get('cameraPosition').export();

    const to = {
      x: cameraPosition.x,
      y: cameraPosition.y,
      z: cameraPosition.z,
    };

    let up = null;
    if (cameraPosition.up !== null && cameraPosition.up !== undefined) {
      up = new THREE.Vector3(cameraPosition.up[0], cameraPosition.up[1], cameraPosition.up[2]);
    }

    this._snapTo(to, up);
  },

  snapToXZ() {
    const cameraOptions = this.api.inputState.get('cameraOptions').export();
    const to = {
      x: cameraOptions.snapXZpos[0],
      y: cameraOptions.snapXZpos[1],
      z: cameraOptions.snapXZpos[2],
    };
    this._snapTo(to);
  },

  snapToYZ() {
    const cameraOptions = this.api.inputState.get('cameraOptions').export();
    const to = {
      x: cameraOptions.snapYZpos[0],
      y: cameraOptions.snapYZpos[1],
      z: cameraOptions.snapYZpos[2],
    };
    this._snapTo(to);
  },

  snapToXY() {
    const cameraOptions = this.api.inputState.get('cameraOptions').export();
    const to = {
      x: cameraOptions.snapXYpos[0],
      y: cameraOptions.snapXYpos[1],
      z: cameraOptions.snapXYpos[2],
    };
    this._snapTo(to);
  },

  _snapTo(to, up = new THREE.Vector3(0, 0, 1)) {
    this.camera.up = up;

    const TWEEN = this.api.imports.TWEEN;
    const from = {
      x: this.camera.position.x,
      y: this.camera.position.y,
      z: this.camera.position.z,
    };

    const _this = this;

    (new TWEEN.Tween(from))
      .to(to, 2000)
      .easing(TWEEN.Easing.Linear.None)
      .onUpdate(function() {
        _this.camera.position.set(this.x, this.y, this.z);
        _this.controls.update();
      })
      .start();

    this.controls.update();
  },

  cameraRotation() {
    this.controls.update();
  },

  autoRotate() {
    const rotate = this.api.inputState.get('autoRotate').export();

    if (rotate) {
      this.controls.autoRotate = true;
      // default rotate speed is 2.0 (30sec per rotation @ 60fps)
      this.controls.autoRotateSpeed = 6.0;
      this.controls.update();
    } else {
      this.controls.autoRotate = false;
      this.controls.update();
    }
  },

  clearScene() {
    const scene = this.scene;
    let myLandscape = {};

    while (scene.getObjectByName('landscape')) {
      myLandscape = scene.getObjectByName('landscape');
      scene.remove(myLandscape);
    }

    while (scene.getObjectByName('myAxesHelper')) {
      const myAxesHelper = scene.getObjectByName('myAxesHelper');
      scene.remove(myAxesHelper);
    }

    while (scene.getObjectByName('x_axis_label')) {
      const x_axis_label = scene.getObjectByName('x_axis_label');
      scene.remove(x_axis_label);
    }

    while (scene.getObjectByName('y_axis_label')) {
      const y_axis_label = scene.getObjectByName('y_axis_label');
      scene.remove(y_axis_label);
    }

    while (scene.getObjectByName('z_axis_label')) {
      const z_axis_label = scene.getObjectByName('z_axis_label');
      scene.remove(z_axis_label);
    }

    while (scene.getObjectByName('x_value_label')) {
      const x_value_label = scene.getObjectByName('x_value_label');
      scene.remove(x_value_label);
    }

    while (scene.getObjectByName('y_value_label')) {
      const y_value_label = scene.getObjectByName('y_value_label');
      scene.remove(y_value_label);
    }

    while (scene.getObjectByName('outline')) {
      const outline = scene.getObjectByName('outline');
      scene.remove(outline);
    }

    while (this.scene.getObjectByName('pin')) {
      const previousPin = this.scene.getObjectByName('pin');
      this.scene.remove(previousPin);
    }
  },

  clearPins() {
    while (this.scene.getObjectByName('pin')) {
      const previousPin = this.scene.getObjectByName('pin');
      this.scene.remove(previousPin);
    }

    // Also need to clear the set that tracks all current pins
    // this.pinData = {};
    this.pinData = [];
    this.currentPinIds.clear();
    this.numberOfPins = 0;
    this.api.output('allPins', []);
    this.api.output('pinKeys', []);
  },

  pointLight() {
    const pointLight = this.api.inputState.get('pointLight').export();
    const scene = this.scene;

    // remove previous pointLight
    scene.remove(scene.getObjectByName('pointLight'));

    if (pointLight.light) {
      const thisLight = new THREE.PointLight(0xffeedd);
      thisLight.position.set(pointLight.xPos, pointLight.yPos, pointLight.zPos);
      thisLight.name = 'pointLight';
      scene.add(thisLight);
    }
  },

  _setScene() {
    const layout = this.api.layoutElement;
    const state = this.api.inputState;
    const pointLight = state.get('pointLight').export();
    const sceneOptions = state.get('sceneOptions').export();
    const TWEEN = this.api.imports.TWEEN;

    const scene = new THREE.Scene();

    if (sceneOptions.drawAxes) {
      const axesHelper = new THREE.AxisHelper(200);
      axesHelper.name = 'myAxesHelper';
      scene.add(axesHelper);
    }

    scene.background = new THREE.Color();

    // soft white light
    const light = new THREE.AmbientLight(0x404040);
    scene.add(light);

    const width = layout.offsetWidth;
    const height = layout.offsetHeight;

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(width, height);
    this.renderer = renderer;

    this.camera = this._makeCamera(width, height);

    // Options: TrackballControls, OrbitControls
    const controls = new THREE[sceneOptions.controlType](this.camera, layout);

    // Don't allow orbit to view the terrain from underneath
    if (sceneOptions.controlType === 'OrbitControls') {
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI / 2;
    }

    this.controls = controls;
    this.controls.noPan = true;

    layout.appendChild(renderer.domElement);

    this.scene = scene;

    // if pointLight is requested, will draw a point of light
    if (pointLight.light) {
      this.pointLight();
    }

    const ambientLight = new THREE.AmbientLight(0x404040); // soft white light
    this.scene.add(ambientLight);

    // When user clicks on layout, run
    this.raycaster = new THREE.Raycaster(); // create once
    this.mouse = new THREE.Vector2(); // create once

    const _this = this;
    render();

    function render() {
      TWEEN.update();
      _this.controls.update();
      requestAnimationFrame(render);
      renderer.render(scene, _this.camera);
    }
  },

  _onResize() {
    const layout = this.api.layoutElement;
    const width = layout.offsetWidth;
    const height = layout.offsetHeight;

    if (this.camera) {
      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();
    }
    if (this.renderer) {
      this.renderer.setSize(width, height);
    }
  },

  _onMouseDown(event) {
    this.mouseLocationBefore.x = event.clientX;
    this.mouseLocationBefore.y = event.clientY;

    this.mouseLocationAfter.x = event.clientX;
    this.mouseLocationAfter.y = event.clientY;

    this.mouseFlag = false;
  },

  _onMouseMove(event) {
    this.mouseLocationAfter.x = event.clientX;
    this.mouseLocationAfter.y = event.clientY;

    this.mouseFlag = true;
  },

  _onMouseUp(event) {
    const a = this.mouseLocationAfter.x - this.mouseLocationBefore.x;
    const b = this.mouseLocationAfter.y - this.mouseLocationBefore.y;
    const distance = Math.sqrt((a * a) + (b * b));

    if (!this.mouseFlag && distance < 10) {
      this._castRay(event);
    }
  },

  _castRay(event) {
    const rect = this.api.layoutElement.getBoundingClientRect();
    this.mouse.x = (((event.clientX - rect.left) / (rect.width)) * 2) - 1;
    this.mouse.y = -(((event.clientY - rect.top) / (rect.height)) * 2) + 1;

    this.raycaster.setFromCamera(this.mouse, this.camera);

    // Check the closest intersecting object
    const intersection = this.raycaster.intersectObjects(this.scene.children, true)[0];

    if (intersection && intersection.object.name === 'pinhead') {
      this._handlePinClick(intersection);
    } else if (intersection && intersection.object.name === 'landscape') {
      this._handleLandClick(intersection);
    } else {
      this._handleOutsideClick();
    }
  },

  _handlePinClick(intersection) {
    let myPinData = [];

    this.pinData.forEach(thisPin => {
      if (thisPin.uuid === intersection.object.uuid) {
        myPinData = thisPin.projectedIds;
      }
    });

    this.api.output('clickedPin', myPinData);

    // TODO find some way to recall the data points from the pin
  },

  _handleLandClick(intersection) {
    // If multiPins is false, all previous pins must be removed
    if (!this.currentPinOptions.multiPins) {
      this.clearPins();
    }
    if (!this.currentPinOptions.clickToPin) {
      return;
    }

    // Find closest vertex and associated data
    const closestVertex = this._findClosestVertex(intersection);
    const binnedIds = closestVertex.binnedIds;
    let position = {};
    // Pinning the closest vertex
    if (this.currentPinOptions.pinClosestVertex) {
      position = {
        x: closestVertex.x,
        y: closestVertex.y,
        z: closestVertex.z,
      };

    // Pinning the exact spot of the click
    } else {
      position = {
        x: intersection.point.x,
        y: intersection.point.y,
        z: intersection.point.z,
      };
    }

    this._addPin(position, binnedIds);

    this.api.output('droppedPin', binnedIds);
    binnedIds.forEach(thisId => {
      this.currentPinIds.add(thisId);
    });
    this._outputBinnedIds();
  },

  _handleOutsideClick() {
    if (this.currentPinOptions.clearOnOutsideClick) {
      this.clearPins();
    }

    if (this.currentPinOptions.clickToPin) {
      // reset all data associated with pins
      this.pinData = [];
      this.api.output('droppedPin', []);
    }
  },

  _outputBinnedIds() {
    const theseIds = [];
    this.currentPinIds.forEach(thisId => {
      theseIds.push(thisId);
    });
    this.api.output('allPins', theseIds);
  },

  _addPin(position, binnedIds) {
    const state = this.api.inputState;
    const data = state.get(['data', 'points']).export();
    const terrainOptions = state.get('terrainOptions').export();

    let newColor = {};
    let pinheadColor = {};
    let geometry = new THREE.SphereGeometry(3);
    if (terrainOptions.alternatePinColors) {
      pinheadColor = d3.interpolateRainbow(this.numberOfPins / 10);
      newColor = new THREE.Color(pinheadColor);
    } else {
      newColor = 0xff0000;
      pinheadColor = newColor;
    }
    let material = new THREE.MeshBasicMaterial({ color: newColor });
    const pinhead = new THREE.Mesh(geometry, material);
    pinhead.position.set(position.x, position.y, position.z + 7);
    pinhead.name = 'pinhead';
    geometry = new THREE.CylinderGeometry(1, 0.2, 6, 8);
    material = new THREE.MeshBasicMaterial({ color: 0xc0c0c0 });
    const pinpoint = new THREE.Mesh(geometry, material);
    pinpoint.position.set(position.x, position.y, position.z + 3);
    pinpoint.rotation.x = Math.PI / 2;
    pinpoint.name = 'pinpoint';
    this.pin = new THREE.Group();
    this.pin.add(pinhead);
    this.pin.add(pinpoint);
    this.pin.name = 'pin';
    this.scene.add(this.pin);

    // add the pin's key data to the this.pinData list
    const thisPinData = {};
    thisPinData.uuid = pinhead.uuid;
    thisPinData.projectedIds = binnedIds;
    thisPinData.position = position;
    thisPinData.color = pinheadColor;

    // Searches objects in data array
    // returns only objects whose projectedIds
    // match an id in binnedIds
    thisPinData.data = data.filter(thisPoint => binnedIds.includes(thisPoint.projectedId));

    this.pinData.push(thisPinData);

    // output the current pin key data
    this.api.output('pinKeys', this.pinData);

    if (this.numberOfPins < 9) {
      this.numberOfPins++;
    } else {
      this.numberOfPins = 0;
    }
  },

  setPins() {
    const state = this.api.inputState;
    const setPins = state.get('setPins').export();

    this.clearPins();

    // Work backward from projected data ids to vertex locations
    // set will make sure no duplicate pins are made on same vertex
    const pinIndices = new Set();

    setPins.forEach(thisPin => {
      pinIndices.add(this._findVertexIndexFromData(thisPin));
      this.numberOfPins++;
    });

    // Pin coordinates are resolved for each index
    // and pins are added at those coordinates
    pinIndices.forEach(thisPin => {
      const position = this._findCoordinateFromVertexIndex(thisPin);
      const binnedIds = this._findBinnedIdsFromIndex(thisPin);
      this._addPin(position, binnedIds);
      binnedIds.forEach(thisId => {
        this.currentPinIds.add(thisId);
      });
    });

    // One entity will put a pin over the vertex which may
    // have other entities binned.
    // Collect all binned ids for all vertices in pinIndices
    // and output those to the setPins port.
    const allEntities = [];
    pinIndices.forEach(thisPin => {
      const projectedIds = this._findBinnedIdsFromIndex(thisPin);
      projectedIds.forEach(thisId => {
        allEntities.push(thisId);
      });
    });

    this.api.output('setPins', allEntities);
    this._outputBinnedIds();
  },

  deletePin() {
    const state = this.api.inputState;
    const deletePin = state.get('deletePin').export();

    // 1. Extract the pin uuid from this.pinData object using
    // deletePin[0] and the projectedIds from this.pinData
    const pinToDelete = this.pinData.filter(thisPin => (
      thisPin.projectedIds.includes(deletePin[0])
    ));

    // 2. Iterate through this.scene to find pin and delete it
    this.scene.children.forEach(thisChild => {
      if (thisChild.name === 'pin') {
        thisChild.children.forEach(thisPinChild => {
          if (thisPinChild.uuid === pinToDelete[0].uuid) {
            this.scene.remove(thisChild);
          }
        });
      }
    });

    // 3. Delete from the set this.currentPinIds
    pinToDelete[0].projectedIds.forEach(thisProjectedId => { this.currentPinIds.delete(thisProjectedId); });

    // 4. Delete the pin from this.pinData
    this.pinData = this.pinData.filter(thisPin => !thisPin.projectedIds.includes(deletePin[0]));

    // 5. Output deleted pin
    this.api.output('deletedPin', pinToDelete[0].projectedIds);

    // 6. Update allPins output
    this._outputBinnedIds();

    // 7. Update pinKeys output
    this.api.output('pinKeys', this.pinData);
  },

  highlightPin() {
    const state = this.api.inputState;
    const highlightPin = state.get('highlightPin').export();

    // highlightPin contains projectedIds
    // this.pinData contains each pin as an object

    // Extract the pin from this.pinData object using
    // highlightPin[0] and the projectedIds from this.pinData
    const myPin = this.pinData.filter(thisPin => thisPin.projectedIds.includes(highlightPin[0]))[0];

    this.scene.children
      .filter(thisPin => thisPin.name === 'pin')[0]
      .children
      .filter(thisPinChild => thisPinChild.uuid === myPin.uuid)[0]
      .material.color.setHex(0xffdcdc);
  },

  unHighlightPins() {
    // Collect all pins and set pinhead colors back to red
    const pins = this.scene.children.filter(thisObject => thisObject.name === 'pin');

    pins.forEach(thisPin => {
      thisPin.children.filter(thisPinChild => thisPinChild.name === 'pinhead')[0]
      .material.color.setHex(0xff0000);
    });
  },

  _findClosestVertex(here) {
    // get coordinate of point of interest
    const myCoordinate = here.point;
    const myVertices = here.object.geometry.vertices;
    let shortestDistance = 100;
    let closestVertexIndex = null;

    // search landscape for closest vertex
    myVertices.forEach((thisVertex, thisVertexIndex) => {
      const xDist = Math.abs(thisVertex.x - myCoordinate.x);
      const yDist = Math.abs(thisVertex.y - myCoordinate.y);
      const hypDist = Math.hypot(xDist, yDist);

      // if searching for closest vertex with real values
      if (this.currentPinOptions.findClosestValues) {
        const isCloser = hypDist < shortestDistance &&
          this.terrainData[thisVertexIndex].binnedIds.length > 0;
        if (isCloser) {
          shortestDistance = hypDist;
          closestVertexIndex = thisVertexIndex;
        }

      // if just searching for closest vertex regardless of value
      } else if (hypDist < shortestDistance) {
        shortestDistance = hypDist;
        closestVertexIndex = thisVertexIndex;
      }
    });

    const closestVertex = this.terrainData[closestVertexIndex];

    closestVertex.x = myVertices[closestVertexIndex].x;
    closestVertex.y = myVertices[closestVertexIndex].y;
    closestVertex.z = myVertices[closestVertexIndex].z;

    // return closestVertex.binnedIds;
    return closestVertex;
  },

  _findVertexIndexFromData(projectedId) {
    // Triggered by this.setPin()
    let vertexIndex = null;

    this.terrainData.forEach((thisVertex, thisVertexIndex) => {
      if (thisVertex.binnedIds.includes(projectedId)) {
        vertexIndex = thisVertexIndex;
      }
    });

    return vertexIndex;
  },

  _findCoordinateFromVertexIndex(vertexIndex) {
    let pinPosition = null;

    const landscape = this.scene.getObjectByName('landscape');
    const vertices = landscape.geometry.vertices;
    pinPosition = vertices[vertexIndex];

    return pinPosition;
  },

  _findCoordinateFromData(projectedId) {
    let pinPosition = null;

    this.terrainData.forEach((thisVertex, thisVertexIndex) => {
      if (thisVertex.binnedIds.includes(projectedId)) {
        const landscape = this.scene.getObjectByName('landscape');
        const vertices = landscape.geometry.vertices;
        pinPosition = vertices[thisVertexIndex];
      }
    });

    return pinPosition;
  },

  _findBinnedIdsFromIndex(index) {
    const binnedIds = this.terrainData[index].binnedIds;
    return binnedIds;
  },

  pinOptions() {
    const state = this.api.inputState;
    const pinOptions = state.get('pinOptions').export();

    if (!pinOptions.multiPins) {
      this.clearPins();
    }

    this.currentPinOptions = pinOptions;
  },

  _makeCamera(width, height) {
    const state = this.api.inputState;
    const options = state.get('options').export();
    const cameraPosition = state.get('cameraPosition').export();
    let camera;

    if (options.camera === 'perspective') {
      camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
    } else if (options.camera === 'orthographic') {
      const left = width / -16;
      const right = width / 16;
      const top = height / 16;
      const bottom = height / -16;
      const near = -200;
      const far = 500;
      const zoom = 1;
      camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far, zoom);
    }

    camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);

    // setting up position
    let up = {};
    if (cameraPosition.up !== null && cameraPosition.up !== undefined) {
      up = new THREE.Vector3(cameraPosition.up[0], cameraPosition.up[1], cameraPosition.up[2]);
    } else {
      up = new THREE.Vector3(0, 0, 1);
    }
    camera.up = up;

    return camera;
  },

  _addPlane() {
    const {
      smooth,
      scaleZ,
      colorByValue,
      wireframe,
    } = this.api.inputState.get('terrainOptions').export();

    const data = this.terrainData;
    const scene = this.scene;

    this.widthSegments = this._calcSegements(data, 'xVal');
    this.heightSegments = this._calcSegements(data, 'yVal');

    let geometry = new THREE.PlaneGeometry(100, 100, this.widthSegments, this.heightSegments);

    for (let i = 0, l = geometry.vertices.length; i < l; i++) {
      geometry.vertices[i].z = data[i].z;
      geometry.vertices[i].colorVal = data[i].colorVal;
    }

    // apply smoothing, if requested
    if (smooth) {
      geometry = this._smoothTerrain(geometry);
    }

    // apply z scalinng, if requested
    if (scaleZ) {
      geometry = this._scaleTerrain(geometry);
    }

    // plane will later be given a base color if there is a hexColor
    // colorize if colorByValue is true
    if (colorByValue) {
      geometry = this._colorizeTerrain(geometry);
    }

    const material = new THREE.MeshPhongMaterial({
      vertexColors: THREE.VertexColors,
      wireframe,
      side: THREE.DoubleSide,
    });

    const plane = new THREE.Mesh(geometry, material);
    plane.name = 'landscape';
    scene.add(plane);
  },

  _scaleTerrain(geometry) {
    const options = this.api.inputState.get('terrainOptions').export();

    const myGeometry = geometry;
    let geoMaxZ = 0.0;
    let scaleFactor = 0.0;

    // Locate the tallest Z value
    myGeometry.vertices.forEach(thisVertex => {
      if (thisVertex.z > geoMaxZ) {
        geoMaxZ = thisVertex.z;
      }
    });

    // If the maximum Z in the data is larger than the maxZ in options,
    // then the scale factor will be the difference between the two divided
    // by the maximum Z in  the data.
    if (geoMaxZ > options.maxZ) {
      scaleFactor = 1 - ((geoMaxZ - options.maxZ) / geoMaxZ);
    } else {
      scaleFactor = 1 + ((options.maxZ - geoMaxZ) / geoMaxZ);
    }

    myGeometry.vertices.forEach(thisVertex => {
      thisVertex.z *= scaleFactor;
      // If logZ is true, apply additional scaling with logZ
      // (a z value of 10/10 = 10/10, 5/10 = 6.9/10)
      if (options.logZ) {
        if (thisVertex.z > 0) {
          thisVertex.z *= (Math.log((thisVertex.z / options.maxZ) * 10) / (Math.log(10)));
        }
      }
    });

    return myGeometry;
  },

  /**
   * function is called when drawing terrain when colorByValue is true
   * @param  {} geometry
   * @return {}
   */
  _colorizeTerrain(geometry) {
    const terrainOptions = this.api.inputState.get('terrainOptions').export();
    const widthSegments = geometry.parameters.widthSegments;
    const heightSegments = geometry.parameters.heightSegments;

    // map out faces to vertices
    // face directory is only used for coloring purposes
    const faceDirectory = this._mapFaces(widthSegments, heightSegments);

    if (terrainOptions.hexColor !== '' && terrainOptions.hexColor !== null) {
      // color by value with the single color terrainOptions.hexColor
      geometry = this._colorByHex(geometry, faceDirectory);
    } else if (terrainOptions.colorScale !== '' && terrainOptions.colorScale !== null) {
      // color by value when colorScale is not empty
      geometry = this._colorByScale(geometry, faceDirectory);
    } else {
      // neother hexColor or colorScale is set so return geometry without modification
      return geometry;
    }

    return geometry;
  },

  _mapFaces(widthSegments, heightSegments) {
    // Terrain can only be colored by coloring the faces directly.
    // Faces can be colored by each of their three vertices.
    // However, the 'geometry' object of the terrain does not match
    // faces to vertices directly. Therefore, this function was built
    // to map those faces to vertices.
    // Each element of facesDirectory array represents one face (faces are drawn
    // from left-right, filling up the back row of the terrain first,
    // then moving forward).
    // Each face has three elements, each an integer indicating the index for the
    // corresponding vertices. Vertices are counted from back-left to front-right
    // as well.

    const faceDirectory = [];
    let i = 0;

    for (let y = 0; y < heightSegments; y++) {
      for (let x = 0; x < (widthSegments * 2); x++) {
        let thisFace = [];
        if (y === 0 && x === 0) {
          thisFace = [0, widthSegments + 1, 1];
          faceDirectory.push(thisFace);
        }
        if (y === 0 && x === 1) {
          thisFace = [widthSegments + 1, widthSegments + 2, 1];
          faceDirectory.push(thisFace);
        }
        if (y > 0 && x === 0) {
          thisFace.push(faceDirectory[i - 2][0] + 2);
          thisFace.push(faceDirectory[i - 2][1] + 2);
          thisFace.push(faceDirectory[i - 2][2] + 2);
          faceDirectory.push(thisFace);
        }
        if (y > 0 && x === 1) {
          thisFace.push(faceDirectory[i - 2][0] + 2);
          thisFace.push(faceDirectory[i - 2][1] + 2);
          thisFace.push(faceDirectory[i - 2][2] + 2);
          faceDirectory.push(thisFace);
        }
        if (x > 1) {
          thisFace.push(faceDirectory[i - 2][0] + 1);
          thisFace.push(faceDirectory[i - 2][1] + 1);
          thisFace.push(faceDirectory[i - 2][2] + 1);
          faceDirectory.push(thisFace);
        }
        i++;
      }
    }

    return faceDirectory;
  },

  _colorByHex(geometry, faceDirectory) {
    // Will colorize the terrain by the colorVal of each vertex
    // and hexColor
    const terrainOptions = this.api.inputState.get('terrainOptions').export();

    const hexColor = parseInt(`0x${terrainOptions.hexColor}`, 16);
    const myColor = new THREE.Color(hexColor);
    const myHSL = myColor.getHSL();
    // The 0.2 L value to allow more room for z coloring
    myColor.setHSL(myHSL.h, myHSL.s, 0.2);

    // allVertices stores color values for each vertex
    const allVertices = [];
    let maxColorValue = 0;

    // look for max color val from this.terrainData instead of z
    geometry.vertices.forEach(thisVertex => {
      allVertices.push(thisVertex.colorVal);
      if (thisVertex.colorVal > maxColorValue) {
        maxColorValue = thisVertex.colorVal;
      }
    });

    const colorGradient = (0.8 / maxColorValue);

    geometry.faces.forEach((thisFace, faceIndex) => {
      let thisVertexIndex = 0;
      for (let v = 0; v < 3; v++) {
        const newColor = new THREE.Color();
        newColor.setHSL(0.125, 1.0, 0.2);
        thisFace.vertexColors[v] = newColor;
        thisVertexIndex = faceDirectory[faceIndex][v];
        if (allVertices[thisVertexIndex] > 0) {
          // newColor.setHSL( 0.125, 1.0, (allVertices[thisVertexIndex] * colorGradient) + 0.2);
          newColor.setHSL(0.125, 1.0, (allVertices[thisVertexIndex] * colorGradient) + 0.2);
          thisFace.vertexColors[v] = newColor;
        }
      }
    });

    return geometry;
  },

  _colorByScale(geometry, faceDirectory) {
    // Will colorize the terrain by the colorVal of each vertex
    // and colorScale

    // allVertices stores color values for each vertex
    const allVertices = [];
    let maxColorValue = 0;

    geometry.vertices.forEach(thisVertex => {
      allVertices.push(thisVertex.colorVal);
      if (thisVertex.colorVal > maxColorValue) {
        maxColorValue = thisVertex.colorVal;
      }
    });

    geometry.faces.forEach((thisFace, faceIndex) => {
      let thisVertexIndex = 0;
      for (let v = 0; v < 3; v++) {
        thisVertexIndex = faceDirectory[faceIndex][v];
        const myGradient = allVertices[thisVertexIndex] / maxColorValue;
        const thisColor = this._applyColorScale(myGradient);
        const newColor = new THREE.Color(thisColor);
        thisFace.vertexColors[v] = newColor;
      }
    });

    return geometry;
  },

  _applyColorScale(myGradient) {
    const options = this.api.inputState.get('terrainOptions').export();
    const myColor = d3[options.colorScale](myGradient);

    return myColor;
  },

  _addThisText(text) {
    // const labelOptions = this.api.inputState.get('labelOptions').export();

    const label = text.label;
    const size = text.size;
    const color = text.color;
    const name = text.name;
    const position = text.position;
    const rotation = text.rotation;

    const _this = this;

    const helvetiker_regular = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/fonts/helvetiker_regular.typeface.json';
    const loader = new THREE.FontLoader();

    loader.load(helvetiker_regular, font => {
      // let myXLabel = labelOptions.xLabel;
      const labelGeom = new THREE.TextGeometry(label, {
        font,
        size,
        height: 0,
        curveSegments: 12,
        bevelSize: 8,
        bevelSegments: 5,
      });
      const labelGeomMaterial = new THREE.MeshPhongMaterial(
        {
          color,
          specular: 0xffffff }
      );
      const myLabel = new THREE.Mesh(labelGeom, labelGeomMaterial);
      myLabel.name = name;
      myLabel.position.set(position.x, position.y, position.z);
      if (text.rotation !== null) {
        myLabel.rotation.x = rotation.x;
        myLabel.rotation.y = rotation.y;
        myLabel.rotation.z = rotation.z;
      }
      _this.scene.add(myLabel);
    }
    );
  },

  _addAxesLabels() {
    const labelOptions = this.api.inputState.get('labelOptions').export();

    const myXLabel = labelOptions.xLabel;
    if (myXLabel !== '') {
      const text = {
        label: myXLabel,
        size: 4,
        color: 0xff0000,
        name: 'x_axis_label',
        position: {
          x: labelOptions.xLabelPosition[0],
          y: labelOptions.xLabelPosition[1],
          z: labelOptions.xLabelPosition[2],
        },
        rotation: {
          x: labelOptions.xLabelRotation[0] * (Math.PI / 180),
          y: labelOptions.xLabelRotation[1] * (Math.PI / 180),
          z: labelOptions.xLabelRotation[2] * (Math.PI / 180),
        },
      };
      this._addThisText(text);
    }

    const myYLabel = labelOptions.yLabel;
    if (myYLabel !== '') {
      const text = {
        label: myYLabel,
        size: 4,
        color: 0x00ff00,
        name: 'y_axis_label',
        position: {
          x: labelOptions.yLabelPosition[0],
          y: labelOptions.yLabelPosition[1],
          z: labelOptions.yLabelPosition[2],
        },
        rotation: {
          x: labelOptions.yLabelRotation[0] * (Math.PI / 180),
          y: labelOptions.yLabelRotation[1] * (Math.PI / 180),
          z: labelOptions.yLabelRotation[2] * (Math.PI / 180),
        },
      };
      this._addThisText(text);
    }

    const myZLabel = labelOptions.zLabel;
    if (labelOptions.zLabel !== '') {
      const text = {
        label: myZLabel,
        size: 4,
        color: 0x0000ff,
        name: 'z_axis_label',
        position: {
          x: labelOptions.zLabelPosition[0],
          y: labelOptions.zLabelPosition[1],
          z: labelOptions.zLabelPosition[2],
        },
        rotation: {
          x: labelOptions.zLabelRotation[0] * (Math.PI / 180),
          y: labelOptions.zLabelRotation[1] * (Math.PI / 180),
          z: labelOptions.zLabelRotation[2] * (Math.PI / 180),
        },
      };
      this._addThisText(text);
    }
  },

  _addValueLabels() {
    const labelOptions = this.api.inputState.get('labelOptions').export();

    const myXValues = labelOptions.xValues;
    const xValueDivision = 100 / myXValues.length;
    const myYValues = labelOptions.yValues;
    const yValueDivision = 100 / myYValues.length;

    myXValues.forEach((thisXValue, pos) => {
      const thisXPos = (pos * xValueDivision) + (xValueDivision * 0.5) + labelOptions.xValuesPosition[0];
      const text = {
        label: thisXValue,
        size: 3,
        color: 0x000000,
        name: 'x_value_label',
        position: {
          x: thisXPos,
          y: labelOptions.xValuesPosition[1],
          z: labelOptions.xValuesPosition[2],
        },
        rotation: {
          x: labelOptions.xValuesRotation[0] * (Math.PI / 180),
          y: labelOptions.xValuesRotation[1] * (Math.PI / 180),
          z: labelOptions.xValuesRotation[2] * (Math.PI / 180),
        },
      };
      this._addThisText(text);
    });

    myYValues.forEach((thisYValue, pos) => {
      const thisYPos = (pos * yValueDivision) + (yValueDivision * 0.5) + labelOptions.yValuesPosition[1];
      const text = {
        label: thisYValue,
        size: 3,
        color: 0x000000,
        name: 'y_value_label',
        position: {
          x: labelOptions.yValuesPosition[0],
          y: thisYPos,
          z: labelOptions.yValuesPosition[2],
        },
        rotation: {
          x: labelOptions.yValuesRotation[0] * (Math.PI / 180),
          y: labelOptions.yValuesRotation[1] * (Math.PI / 180),
          z: labelOptions.yValuesRotation[2] * (Math.PI / 180),
        },
      };
      this._addThisText(text);
    });
  },

  _drawOutline() {
    const scene = this.scene;
    const geometry = new THREE.PlaneGeometry(126, 114, 1, 1);
    const material = new THREE.MeshPhongMaterial({
      color: 0x000000,
      vertexColors: THREE.VertexColors,
      side: THREE.DoubleSide,
    });

    const outline = new THREE.Mesh(geometry, material);

    outline.name = 'outline';
    outline.position.x = -13;
    outline.position.y = -7;
    outline.position.z = -1;

    scene.add(outline);
  },

  _calcSegements(data, prop) {
    const uniqueSegments = new Set();

    data.forEach(thisPoint => {
      uniqueSegments.add(thisPoint[prop]);
    });

    return (uniqueSegments.size - 1);
  },

  _makeTerrainData() {
    const points = this.api.inputState.get(['data', 'points']).export();
    const terrainOptions = this.api.inputState.get('terrainOptions').export();

    const {
      maxZ,
      minZ,
      binnedData,
    } = _binData(points, terrainOptions);

    this.maxZ = maxZ;
    this.minZ = minZ;
    this.terrainData = binnedData;
    this.api.output('terrainData', binnedData);
  },

  _smoothTerrain(geometry) {
    const options = this.api.inputState.get('terrainOptions').export();

    // creates a list of neighboring verticies
    // that should be changed to accomodate smoothing
    let allNeighbors = [];

    // First, enforce a permiter, as we can't make assumptions about
    // data that may exist beyond the terrain. Points on the perimeter
    // would be improperly weighted if perimeter not enforced.
    // Perimeter is the same size as the smoothing radius.
    // All vertices in thins perimeter ar to be set to 0 height.
    if (options.bestFitSmooth) {
      geometry = this._enforcePerimeter(geometry, options.smooth);
    }

    // Now that perimeter has been enforced, search for all vertices which
    // have some height.
    // Then, find the neighbors for each of those vertices.

    geometry.vertices.forEach((thisVertex, vertexIndex) => {
      let theseNeighbors = [];
      if (thisVertex.z > 0) {
        // identify all points within a specified radius, by index
        theseNeighbors = this._findAdjacent(thisVertex, geometry);
      }
      // If the _findAdjacent fx returns neighbors,
      // append those neighbors to the list of all neighbors.
      if (theseNeighbors.length) {
        allNeighbors = allNeighbors.concat(theseNeighbors);
      }
    });

    // Remove from the list of neighbors
    // vertices that are part of the border
    if (options.borderWidth) {
      allNeighbors = this._removeBorderVertices(allNeighbors, geometry);
    }

    // What about neighbors that are shared between vertices?
    // Eliminate duplicate vertices by averaging the common values.
    if (options.bestFitSmooth) {
      allNeighbors = this._averageNeighbors(allNeighbors);
    }

    // If using best fit smooth, neighbors values will always change.
    if (options.bestFitSmooth) {
      allNeighbors.forEach(thisNeighbor => {
        geometry.vertices[thisNeighbor.index].z = thisNeighbor.z;
        geometry.vertices[thisNeighbor.index].colorVal = thisNeighbor.colorVal;
        // geometry.vertices[thisNeighbor.index].z = neighborsAvg * Math.cos(Math.PI * (thisNeighbor.distance / myRadius));
      });

    // If not using best fit smooth, only change if resulting z is greater than current z.
    } else {
      allNeighbors.forEach(thisNeighbor => {
        if (geometry.vertices[thisNeighbor.index].z < thisNeighbor.z) {
          geometry.vertices[thisNeighbor.index].z = thisNeighbor.z;
        }
        if (geometry.vertices[thisNeighbor.index].colorVal < thisNeighbor.colorVal) {
          geometry.vertices[thisNeighbor.index].colorVal = thisNeighbor.colorVal;
        }
      });
    }

    return geometry;
  },

  _removeBorderVertices(allNeighbors, geometry) {
    const { borderWidth } = this.api.inputState.get('terrainOptions').export();

    // First identify which vertices in the geometry are border vertices
    // vertices are found in geometry.vertices
    // verticies are indexed from back-left, to right, then forward.

    const borderVertices = [];
    const planeSegments = this.widthSegments + 1;
    let row = 1;
    let column = 1;

    // the first x columns
    // and the last x columns
    // where x is the border width

    geometry.vertices.forEach((thisVertex, thisVertexIndex) => {
      // Border verticies will be the first x rows and the last x rows
      if (row <= borderWidth || row >= (planeSegments - borderWidth)) {
        borderVertices.push(thisVertexIndex);

      // and the first x columns and the last x columns
      } else if (column <= borderWidth || column >= (planeSegments - borderWidth)) {
        borderVertices.push(thisVertexIndex);
      }

      // increment the columns and rows
      if (column >= planeSegments) {
        column = 1;
        row++;
      } else {
        column++;
      }
    });

    const newNeighbors = [];

    allNeighbors.forEach(thisNeighbor => {
      if (!borderVertices.includes(thisNeighbor.index)) {
        newNeighbors.push(thisNeighbor);
      }
    });

    return newNeighbors;
  },

  _enforcePerimeter(geometry, smoothingRadius) {
    let myRadius = 100 / (geometry.parameters.widthSegments + 1);
    myRadius *= smoothingRadius;

    geometry.vertices.forEach(vertex => {
      if (vertex.x < (-50 + myRadius) || vertex.x > (50 - myRadius)) {
        vertex.z = 0;
        vertex.colorVal = 0;
      }
      if (vertex.y < (-50 + myRadius) || vertex.y > (50 - myRadius)) {
        vertex.z = 0;
        vertex.colorVal = 0;
      }
    });

    return geometry;
  },

  _findAdjacent(myVertex, geometry) {
    // takes a single vertex and the landscape geometry
    // returns a duffle of neighboring vertices
    // with their index and height adjustment

    const options = this.api.inputState.get('terrainOptions').export();

    let myRadius = 100 / (geometry.parameters.widthSegments + 1);
    myRadius *= options.smooth;

    const myNeighbors = [];

    geometry.vertices.forEach((vertex, vertexIndex) => {
      const thisNeighbor = {};
      const xDist = Math.abs(vertex.x - myVertex.x);
      const yDist = Math.abs(vertex.y - myVertex.y);
      const hypDist = Math.hypot(xDist, yDist);
      if (hypDist < myRadius) {
        thisNeighbor.index = vertexIndex;
        thisNeighbor.distance = hypDist;
        if (options.bestFitSmooth) {
          thisNeighbor.z = vertex.z;
          thisNeighbor.colorVal = vertex.colorVal;
        } else {
          thisNeighbor.z = myVertex.z * Math.cos((Math.PI / 2) * (hypDist / myRadius));
          thisNeighbor.colorVal = myVertex.colorVal * Math.cos((Math.PI / 2) * (hypDist / myRadius));
        }
        myNeighbors.push(thisNeighbor);
      }
    });

    // Average all the vertices in this local group
    // also average all the colorVals in this group
    // only do this if bestFitSmooth is true
    let neighborsZSum = 0;
    let neighborsColorValSum = 0;
    let neighborsZAvg = 0.0;
    let neighborsColorValAvg = 0.0;
    if (options.bestFitSmooth) {
      myNeighbors.forEach(thisNeighbor => {
        neighborsZSum += thisNeighbor.z;
        neighborsColorValSum += thisNeighbor.colorVal;
      });
      neighborsZAvg = neighborsZSum / myNeighbors.length;
      neighborsColorValAvg = neighborsColorValSum / myNeighbors.length;
      myNeighbors.forEach(thisNeighbor => {
        thisNeighbor.z = neighborsZAvg * Math.cos((Math.PI / 2) * (thisNeighbor.distance / myRadius));
        thisNeighbor.colorVal = neighborsColorValAvg * Math.cos((Math.PI / 2) * (thisNeighbor.distance / myRadius));
      });
    }

    return myNeighbors;
  },

  _averageNeighbors(allNeighbors) {
    // Average the height of vertices who are neighbors to more than one vertex.
    const neighborIndecies = [];

    // create an array with just the indices of single vertices
    allNeighbors.forEach(thisNeighbor => {
      if (!neighborIndecies.includes(thisNeighbor.index)) {
        neighborIndecies.push(thisNeighbor.index);
      }
    });

    // now that we have array of just matching indices, search among those indices.
    // sum all the z values for each of those indices.
    // also sum al color values for each of those indicies.
    const finalNeighbors = [];
    neighborIndecies.forEach(thisIndex => {
      const myNeighbor = {};
      let zSum = 0;
      let colorSum = 0;
      let dSum = 0;
      let indexCount = 0;
      allNeighbors.forEach(thisNeighbor => {
        if (thisNeighbor.index === thisIndex) {
          // indices match, add to sum
          zSum += thisNeighbor.z;
          colorSum += thisNeighbor.colorVal;
          dSum += thisNeighbor.distance;
          indexCount++;
        }
      });
      // after all neighbors have been searched, finish averaging.
      myNeighbor.index = thisIndex;
      myNeighbor.distance = dSum / indexCount;
      myNeighbor.z = zSum / indexCount;
      myNeighbor.colorVal = colorSum / indexCount;
      finalNeighbors.push(myNeighbor);
    });

    return finalNeighbors;
  },
};

function _binData(points, { resolution, borderWidth }) {
  // RESOLUTION = number of lines
  const xBins = resolution;
  const yBins = resolution;

  // contains cut-offs for binning
  let xBinLim = [];
  const yBinLim = [];

  let minX = 0;
  let maxX = 0;
  let minY = 0;
  let maxY = 0;
  let minZ = 0;
  let maxZ = 0;

  // find min and max of each dimension

  points.forEach(thisPoint => {
    if (thisPoint.x < minX) { minX = thisPoint.x; }
    if (thisPoint.x > maxX) { maxX = thisPoint.x; }
    if (thisPoint.y < minY) { minY = thisPoint.y; }
    if (thisPoint.y > maxY) { maxY = thisPoint.y; }
    if (thisPoint.z < minZ) { minZ = thisPoint.z; }
    if (thisPoint.z > maxZ) { maxZ = thisPoint.z; }
  });

  xBinLim.push(minX);
  yBinLim.push(minY);

  // find bin size for x and y dimension

  const binSizeX = (maxX - minX) / (xBins - 1);
  const binSizeY = (maxY - minY) / (yBins - 1);

  for (let i = 1; i < xBins; i++) {
    xBinLim.push(xBinLim[i - 1] + binSizeX);
  }

  // If there is a border specified in terrainOptions.borderWidth,
  // shift the grid accordingly and allow room for two new rows and two new columns
  // all points within these columns will have zero height
  // a 5 x 5 grid (25pts) becomes a 7 x 7 grid (49pts)

  if (borderWidth) {
    // adding x bins before real data
    for (let a = 1; a <= borderWidth; a++) {
      xBinLim.unshift(xBinLim[0] + (binSizeX * a * -1));
    }
    // adding x bins after real data
    for (let b = 1; b <= borderWidth; b++) {
      xBinLim.push(xBinLim[xBinLim.length - 1] + (binSizeX * b));
    }
  }

  // xBinLim must be reversed, because three.js starts drawing points from back to front
  xBinLim = xBinLim.reverse();

  for (let i = 1; i < yBins; i++) {
    yBinLim.push(yBinLim[i - 1] + binSizeY);
  }

  if (borderWidth) {
    // adding y bins before real data
    for (let a = 1; a <= borderWidth; a++) {
      yBinLim.unshift(yBinLim[0] + (binSizeY * a * -1));
    }
    // adding y bins after real data
    for (let b = 1; b <= borderWidth; b++) {
      yBinLim.push(yBinLim[yBinLim.length - 1] + (binSizeY * b));
    }
  }

  const binnedData = [];

  // now each entity/point must be defined
  // left to right, back to front
  xBinLim.forEach(thisXBin => {
    yBinLim.forEach(thisYBin => {
      const thisPoint = {
        xVal: thisXBin,
        yVal: thisYBin,
        n: 0,
        sum: 0,
        colorSum: 0,
        binnedIds: [],
      };

      points.forEach(dataPoint => {
        const isInBin = dataPoint.x >= thisXBin &&
            dataPoint.x < (thisXBin + binSizeX) &&
            dataPoint.y >= thisYBin &&
            dataPoint.y < (thisYBin + binSizeY);

        if (isInBin) {
          thisPoint.n += 1;
          thisPoint.sum += dataPoint.z;
          thisPoint.colorSum += dataPoint.color;
          thisPoint.binnedIds.push(dataPoint.projectedId);
        }
      });
      binnedData.push(thisPoint);
    });
  });

  // now the average for each data bin must be computed
  binnedData.forEach(thisBin => {
    if (thisBin.n) {
      thisBin.z = thisBin.sum / thisBin.n;
      thisBin.colorVal = thisBin.colorSum / thisBin.n;
    } else {
      thisBin.z = 0;
      thisBin.colorVal = 0;
    }
  });

  return {
    maxZ,
    minZ,
    binnedData,
  };
}
