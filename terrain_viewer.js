export default {
	_init() {

		let layout = this.api.layoutElement,
				state = this.api.inputState.export(),
				data = state.data.points;

		this.scene;
		this.renderer;
		this.controls;
		this.camera;
		this.renderer;
		this.maxZ;
		this.minZ;
		this.camera_rotate;
		this.raycaster;
		this.mouse;
		this.layout;
		this.pin;

		this.mouseLocationBefore = {};
		this.mouseLocationAfter = {};

		// this.pinData contains one object for each pin
		// each object has properties for color, position {x,y,z},
		// projectedIds under the pin,
		// and the UUID for the pin group generated by three.js
		// This is oputput directly to the 'pinKeys' output
		// this.pinData is updated in _addPin()
		this.pinData = [];

		// this.numberOfPins is used to generate unique colors for batches of 10 pins
		// the integer is reset after every 10, is not a running total of pins
		this.numberOfPins = 0;

		// this.currentPinIds is a set containing just the projectedIds of all pinned data
		// this makes it easier to just output all pinned data
		// is converted to an array and output 'allPins' in _outputBinnedIds()
		this.currentPinIds = new Set();

		this.currentPinOptions = state.pinOptions;

		this.terrainData = [];
		this.widthSegments = 0;
		this.heightSegments = 0;
		this.mouseFlag = false;

		this._setScene();

		if (data.length > 0) {

			this.data();

		}

	},

	getScene() {

		let scene = this.scene;
		this.api.output("sceneData", scene);

	},

	data() {

		let state = this.api.inputState.export();

		this.clearScene();
		this._makeTerrainData();
		this._addPlane();
		this.labelOptions();

	},

	sceneOptions() {

		let state = this.api.inputState.export();
		let sceneOptions = state.sceneOptions;
		let scene = this.scene;

		if (sceneOptions.drawAxes) {
			let axesHelper = new THREE.AxisHelper(200);
			axesHelper.name = "myAxesHelper";
			scene.add(axesHelper);
		}

		else {
			let axesHelper = scene.getObjectByName( "myAxesHelper" );
			scene.remove(axesHelper);
		}

	},

	terrainOptions() {

		let state = this.api.inputState.export();

		this.clearScene();
		this._makeTerrainData();
		this._addPlane();
		this.labelOptions();

	},

	labelOptions() {

		let state = this.api.inputState.export();
		let scene = this.scene;

		while (scene.getObjectByName("x_axis_label")) {
			let x_axis_label = scene.getObjectByName("x_axis_label");
			scene.remove(x_axis_label);
		}

		while (scene.getObjectByName("y_axis_label")) {
			let y_axis_label = scene.getObjectByName("y_axis_label");
			scene.remove(y_axis_label);
		}

		while (scene.getObjectByName("z_axis_label")) {
			let z_axis_label = scene.getObjectByName("z_axis_label");
			scene.remove(z_axis_label);
		}

		while (scene.getObjectByName("x_value_label")) {
			let x_value_label = scene.getObjectByName("x_value_label");
			scene.remove(x_value_label);
		}

		while (scene.getObjectByName("y_value_label")) {
			let y_value_label = scene.getObjectByName("y_value_label");
			scene.remove(y_value_label);
		}

		while (scene.getObjectByName("outline")) {
			let outline = scene.getObjectByName("outline");
			scene.remove(outline);
		}

		if (state.labelOptions.drawLabels) {
			this._addAxesLabels();
			if (state.labelOptions.xValues.length > 0 || state.labelOptions.xValues.length > 0) {
				this._addValueLabels();
			}
		}

		if (state.labelOptions.drawOutline) {
			this._drawOutline();
		}

	},

  cameraPosition() {

    const state = this.api.inputState.export();
    const options = state.options;
    const cameraPosition = state.cameraPosition;

		let to = {
			x: cameraPosition.x,
			y: cameraPosition.y,
			z: cameraPosition.z,
		};

		let up = {};

		if (cameraPosition.up !== null && cameraPosition.up !== undefined) {
			up = new THREE.Vector3(cameraPosition.up[0],cameraPosition.up[1],cameraPosition.up[2]);
		}

		else {
			up = new THREE.Vector3(0,1,0);
		}


		this._snapTo(to, up);

  },

	snapToXZ() {
		const state = this.api.inputState.export();
    const cameraOptions = state.cameraOptions;

		let to = {
			x: cameraOptions.snapXZpos[0],
			y: cameraOptions.snapXZpos[1],
			z: cameraOptions.snapXZpos[2],
		};

		let up = new THREE.Vector3(0,0,1);

		this._snapTo(to, up);

	},

	snapToYZ() {
		const state = this.api.inputState.export();
    const cameraOptions = state.cameraOptions;

		let to = {
			x: cameraOptions.snapYZpos[0],
			y: cameraOptions.snapYZpos[1],
			z: cameraOptions.snapYZpos[2],
		};

		let up = new THREE.Vector3(0,0,1);

		this._snapTo(to, up);

	},

	snapToXY() {
		const state = this.api.inputState.export();
    const cameraOptions = state.cameraOptions;

		let to = {
			x: cameraOptions.snapXYpos[0],
			y: cameraOptions.snapXYpos[1],
			z: cameraOptions.snapXYpos[2],
		};

		let up = new THREE.Vector3(0,1,0);

		this._snapTo(to, up);

	},

	_snapTo(to, up) {

		if (up) {
			this.camera.up = up;
		}

		const TWEEN = this.api.imports.TWEEN;

		let from = {
            x: this.camera.position.x,
            y: this.camera.position.y,
            z: this.camera.position.z
        };

		let _this = this;

		let tween = new TWEEN.Tween(from)
        .to(to, 2000)
        .easing(TWEEN.Easing.Linear.None)
        .onUpdate(function () {
        _this.camera.position.set(this.x, this.y, this.z);
				_this.controls.update();
    })
    	.start();

			/*
		if (up) {
			this.camera.up = new THREE.Vector3(0,0,1);
		}
		*/

		this.controls.update();

	},

	cameraRotation() {

		const state = this.api.inputState.export();
    const options = state.options;
    const cameraRotation = state.cameraRotation;

		// this.controls.reset();

		//let thisCamera = this.camera;

		/*
		this.camera.rotation.x = (this.camera.rotation.x) + Math.PI * cameraRotation.x / 180;
		this.camera.rotation.y = Math.PI * cameraRotation.y / 180;
		this.camera.rotation.z = Math.PI * cameraRotation.z / 180;
		*/

		this.camera.rotation.y = Math.PI;
		//this.camera = thisCamera;

		//controls.update() must be called after any manual changes to the camera's transform

		//this.controls.noRotate = true;
		this.controls.update();


	},

	autoRotate() {

		const state = this.api.inputState.export();
    const rotate = state.autoRotate;

		if (rotate) {

			this.controls.autoRotate = true;
			// default rotate speed is 2.0 (30sec per rotation @ 60fps)
			this.controls.autoRotateSpeed = 6.0;
			this.controls.update();

		}

		else {

			this.controls.autoRotate = false;
			this.controls.update();

		}

	},

	clearScene() {

		let scene = this.scene;

		let myLandscape = {};
		let myXaxis = {};
		let myYaxis = {};
		let myZaxis = {};

		while (scene.getObjectByName( "landscape" )) {
			myLandscape = scene.getObjectByName( "landscape" );
			scene.remove(myLandscape);
		}

		while (scene.getObjectByName("myAxesHelper")) {
			let myAxesHelper = scene.getObjectByName("myAxesHelper");
			scene.remove(myAxesHelper);
		}

		while (scene.getObjectByName("x_axis_label")) {
			let x_axis_label = scene.getObjectByName("x_axis_label");
			scene.remove(x_axis_label);
		}

		while (scene.getObjectByName("y_axis_label")) {
			let y_axis_label = scene.getObjectByName("y_axis_label");
			scene.remove(y_axis_label);
		}

		while (scene.getObjectByName("z_axis_label")) {
			let z_axis_label = scene.getObjectByName("z_axis_label");
			scene.remove(z_axis_label);
		}

		while (scene.getObjectByName("x_value_label")) {
			let x_value_label = scene.getObjectByName("x_value_label");
			scene.remove(x_value_label);
		}

		while (scene.getObjectByName("y_value_label")) {
			let y_value_label = scene.getObjectByName("y_value_label");
			scene.remove(y_value_label);
		}

		while (scene.getObjectByName("outline")) {
			let outline = scene.getObjectByName("outline");
			scene.remove(outline);
		}

		while (this.scene.getObjectByName("pin")) {
			let previousPin = this.scene.getObjectByName("pin");
			this.scene.remove(previousPin);
		}

	},

	clearPins() {

		while (this.scene.getObjectByName("pin")) {
			let previousPin = this.scene.getObjectByName("pin");
			this.scene.remove(previousPin);
		}

		// Also need to clear the set that tracks all current pins
		// this.pinData = {};
		this.pinData = [];
		this.currentPinIds.clear();
		this.numberOfPins = 0;
		this.api.output('allPins', []);
		this.api.output('pinKeys', []);

	},

	pointLight() {

		let state = this.api.inputState.export(),
				pointLight = state.pointLight;

		let scene = this.scene;

		// remove previous pointLight
		scene.remove( scene.getObjectByName( "pointLight" ) );

		if (pointLight.light) {

			let thisLight = new THREE.PointLight( 0xffeedd );
			thisLight.position.set( pointLight.xPos, pointLight.yPos, pointLight.zPos );
			thisLight.name = "pointLight";
			scene.add( thisLight );

		}

	},

  _setScene() {

		let layout = this.api.layoutElement,
				state = this.api.inputState.export(),
				data = state.data.points,
				pointLight = state.pointLight,
				sceneOptions = state.sceneOptions,
				TWEEN = this.api.imports.TWEEN;

    let width  = layout.offsetWidth,
        height = layout.offsetHeight;

    let scene = new THREE.Scene();

		if (sceneOptions.drawAxes) {
			let axesHelper = new THREE.AxisHelper(200);
			axesHelper.name = "myAxesHelper";
			scene.add(axesHelper);
		}

    scene.background = new THREE.Color();

		// soft white light
		let light = new THREE.AmbientLight( 0x404040 );
		scene.add( light );

    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(width, height);
		this.renderer = renderer;

		this.camera = this._makeCamera(width, height);
		// this.camera.lookAt(new THREE.Vector3(0,0,0));
    let camera = this.camera;

		let controls = new THREE[sceneOptions.controlType](this.camera, layout);
		//let controls = new THREE.TrackballControls(this.camera, layout);
    // let controls = new THREE.OrbitControls(this.camera, layout);
		this.controls = controls;
		this.controls.noPan = true;

    layout.appendChild(renderer.domElement);

		this.scene = scene;

		// if pointLight is requested, will draw a point of light
		if (pointLight.light) {
			this.pointLight();
		}
		// if no pointLight is requested, then create ambient lighting instead
		//else {
			var ambientLight = new THREE.AmbientLight( 0x404040 ); // soft white light
			this.scene.add( ambientLight );
		//}

		// When user clicks on layout, run
		this.raycaster = new THREE.Raycaster(); // create once
		this.mouse = new THREE.Vector2(); // create once
		this.layout = this.api.layoutElement;
    //layout.addEventListener( 'mousedown', this._onMouseDown.bind(this), false );

		layout.addEventListener( 'mousedown', this._onMouseDown.bind(this), false );
		layout.addEventListener( 'mousemove', this._onMouseMove.bind(this), false );
		layout.addEventListener( 'mouseup', this._onMouseUp.bind(this), false );

		let _this = this;
		render();

		function render() {
				TWEEN.update();
				_this.controls.update();
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }

  },

	_onMouseDown( event ) {

		this.mouseLocationBefore.x = event.clientX;
		this.mouseLocationBefore.y = event.clientY;

		this.mouseLocationAfter.x = event.clientX;
		this.mouseLocationAfter.y = event.clientY;

		this.mouseFlag = false;

	},

	_onMouseMove( event ) {

		this.mouseLocationAfter.x = event.clientX;
		this.mouseLocationAfter.y = event.clientY;

		this.mouseFlag = true;

	},

	_onMouseUp( event ) {

		let a = this.mouseLocationAfter.x - this.mouseLocationBefore.x;
		let b = this.mouseLocationAfter.y - this.mouseLocationBefore.y;
		let distance = Math.sqrt( a*a + b*b );

		if (!this.mouseFlag && distance < 10) {
			this._castRay(event);
		}

	},

	_castRay( event ) {

		let rect = this.layout.getBoundingClientRect();
		this.mouse.x = ( (event.clientX - rect.left) / (rect.width) ) * 2 - 1;
		this.mouse.y = - ( (event.clientY - rect.top) / (rect.height) ) * 2 + 1;

		this.raycaster.setFromCamera( this.mouse, this.camera );
		let objects = {};
		let intersects = this.raycaster.intersectObjects( this.scene.children, true );

		let intersectsLand = false;
		let intersectsPin = false;
		let landIntersection = {};
		let pinIntersection = {};

		// Find the objects that intersect the ray
		if (intersects.length) {
			intersects.forEach( thisObj => {
				// if click intersects the landscape...
				if (thisObj.object.name === "landscape") {
					intersectsLand = true;
					landIntersection = thisObj;
				}
				if (thisObj.object.name === "pinhead") {
					intersectsPin = true;
					pinIntersection = thisObj;
				}
			});
		}

		if (intersectsLand && !intersectsPin) {
			// only intersects landscape
			this._handleLandClicks(intersectsLand, landIntersection);
		}

		if (intersectsPin) {
			// intersects a pin at all
			this._handlePinClick(pinIntersection);
		}

		if (!intersectsLand) {
			// does not intersect a landscape
			this._handleLandClicks(intersectsLand, landIntersection);
		}


	},

	_handlePinClick(pinIntersection) {

		//let myPinData = this.pinData[pinIntersection.object.uuid]

		let myPinData = [];

		this.pinData.forEach( thisPin => {
			if (thisPin.uuid = pinIntersection.object.uuid) {
				myPinData = thisPin.projectedIds;
			}
		});

		this.api.output('clickedPin', myPinData);

		// find some way to recall the data points from the pin


	},

	_handleLandClicks(intersectsLandscape, intersection) {

		// If the ray does not intersect the landscape and
		// pinOptions has clearOnOutsideClick set true,
		// need to delete all current pins
		if (this.currentPinOptions.clearOnOutsideClick && !intersectsLandscape) {
			this.clearPins();
		}

		// If multiPins is false, all previous pins must be removed
		if (!this.currentPinOptions.multiPins) {
			this.clearPins();
		}

		// If the click intersects the landscape
		// and clickToPin is set true
		// Add new pin at location and find closest vertex
		if (intersectsLandscape && this.currentPinOptions.clickToPin) {
			// Find closest vertex and associated data
			let closestVertex = this._findClosestVertex(intersection);
			let binnedIds = closestVertex.binnedIds;
			let position = {};
			// Pinning the closest vertex
			if (this.currentPinOptions.pinClosestVertex) {
				position = {
					x: closestVertex.x,
					y: closestVertex.y,
					z: closestVertex.z
				};
			}
			// Pinning the exact spot of the click
			else {
				position = {
					x: intersection.point.x,
					y: intersection.point.y,
					z: intersection.point.z
				};
			}
			// Add new pin
			this._addPin(position, binnedIds);
			// Output the data
			this.api.output('droppedPin', binnedIds);
			binnedIds.forEach( thisId => {
				this.currentPinIds.add(thisId);
			});
			this._outputBinnedIds();
		}

		// Otherwise, simply output an empty array
		// if clickToPin is true.
		else {
			if (this.currentPinOptions.clickToPin) {
				// reset all data associated with pins
				this.pinData = [];
				this.api.output('droppedPin', []);
			}
		}

	},

	_outputBinnedIds() {

		let theseIds = [];
		this.currentPinIds.forEach( thisId => {
			theseIds.push(thisId);
		});
		this.api.output('allPins', theseIds);

	},

	_addPin(position, binnedIds) {

		const state = this.api.inputState.export();
		const data = state.data.points;
		const terrainOptions = state.terrainOptions;


		let newColor = {};
		let pinheadColor = {};
		let geometry = new THREE.SphereGeometry( 3 );
		if (terrainOptions.alternatePinColors) {
			let pinheadColor = d3.interpolateRainbow(this.numberOfPins / 10);
			newColor = new THREE.Color(pinheadColor);
		}
		else {
			newColor = 0xff0000;
			pinheadColor = newColor;
		}
		let material = new THREE.MeshBasicMaterial( { color: newColor } );
		let pinhead = new THREE.Mesh( geometry, material );
		pinhead.position.set( position.x, position.y, position.z + 7);
		pinhead.name = "pinhead";
		geometry = new THREE.CylinderGeometry( 1, 0.2, 6, 8 );
		material = new THREE.MeshBasicMaterial( {color: 0xc0c0c0} );
		let pinpoint = new THREE.Mesh( geometry, material );
		pinpoint.position.set( position.x, position.y, position.z + 3);
		pinpoint.rotation.x = Math.PI / 2;
		pinpoint.name = "pinpoint";
		this.pin = new THREE.Group();
		this.pin.add( pinhead );
		this.pin.add( pinpoint );
		this.pin.name = "pin";
		this.scene.add( this.pin );

		// add the pin's key data to the this.pinData list
		let thisPinData = {};
		thisPinData.uuid = pinhead.uuid;
		thisPinData.projectedIds = binnedIds;
		thisPinData.position = position;
		thisPinData.color = pinheadColor;

		// Searches objects in data array
		// returns only objects whose projectedIds
		// match an id in binnedIds
		thisPinData.data = data.filter( thisPoint => binnedIds.includes(thisPoint.projectedId));

		this.pinData.push(thisPinData);

		// output the current pin key data
		this.api.output('pinKeys', this.pinData);

		if (this.numberOfPins < 9) {
			this.numberOfPins++;
		}
		else {
			this.numberOfPins = 0;
		}


	},

	setPins() {

		const state = this.api.inputState.export();
		const setPins = state.setPins;

		this.clearPins();

		// Work backward from projected data ids to vertex locations
		// set will make sure no duplicate pins are made on same vertex
		let pinIndices = new Set();

		setPins.forEach( thisPin => {
			pinIndices.add(this._findVertexIndexFromData(thisPin));
			this.numberOfPins++;
		});

		// Pin coordinates are resolved for each index
		// and pins are added at those coordinates
		pinIndices.forEach( thisPin => {
			let position = this._findCoordinateFromVertexIndex(thisPin);
			let binnedIds = this._findBinnedIdsFromIndex(thisPin);
			this._addPin(position, binnedIds);
			binnedIds.forEach( thisId => {
				this.currentPinIds.add(thisId);
			});
		});

		// One entity will put a pin over the vertex which may
		// have other entities binned.
		// Collect all binned ids for all vertices in pinIndices
		// and output those to the setPins port.
		let allEntities = [];
		pinIndices.forEach( thisPin => {
			let projectedIds = this._findBinnedIdsFromIndex(thisPin);
			projectedIds.forEach( thisId => {
				allEntities.push(thisId);
			});
		});

		this.api.output('setPins', allEntities);
		this._outputBinnedIds();

	},

	deletePin() {

		const state = this.api.inputState.export();
		const deletePin = state.deletePin;

		// 1. Extract the pin uuid from this.pinData object using
		// deletePin[0] and the projectedIds from this.pinData
		let pinToDelete = this.pinData.filter( thisPin => thisPin.projectedIds.includes(deletePin[0]));

		// 2. Iterate through this.scene to find pin and delete it
		this.scene.children.forEach( thisChild => {
			if (thisChild.name === "pin") {
				thisChild.children.forEach( thisPinChild => {
					if (thisPinChild.uuid === pinToDelete[0].uuid) {
						this.scene.remove(thisChild);
					}
				});
			}
		});

		// 3. Delete from the set this.currentPinIds
		pinToDelete[0].projectedIds.forEach( thisProjectedId => { this.currentPinIds.delete(thisProjectedId); });

		// 4. Delete the pin from this.pinData
		this.pinData = this.pinData.filter( thisPin => !thisPin.projectedIds.includes(deletePin[0]));

		// 5. Output deleted pin
		this.api.output('deletedPin', pinToDelete[0].projectedIds);

		// 6. Update allPins output
		this._outputBinnedIds();

		// 7. Update pinKeys output
		this.api.output('pinKeys', this.pinData);

	},

	highlightPin() {

		const state = this.api.inputState.export();
		const highlightPin = state.highlightPin;

		// highlightPin contains projectedIds
		// this.pinData contains each pin as an object

		// Extract the pin from this.pinData object using
		// highlightPin[0] and the projectedIds from this.pinData
		let myPin = this.pinData.filter( thisPin => thisPin.projectedIds.includes(highlightPin[0]))[0];

		this.scene.children
			.filter( thisPin => thisPin.name === "pin" )[0]
			.children
			.filter( thisPinChild => thisPinChild.uuid === myPin.uuid)[0]
			.material.color.setHex(0xffdcdc);

	},

	unHighlightPins() {

		// Collect all pins and set pinhead colors back to red
		let pins = this.scene.children.filter( thisObject => thisObject.name === "pin" );

		pins.forEach( thisPin => {
			thisPin.children.filter( thisPinChild => thisPinChild.name === "pinhead" )[0]
			.material.color.setHex(0xff0000);
		});

	},

	_findClosestVertex(here) {

		// get coordinate of point of interest
		let myCoordinate = here.point;
		let myVertices = here.object.geometry.vertices;
		let shortestDistance = 100;
		let closestVertexIndex = null;

		// search landscape for closest vertex
		myVertices.forEach( (thisVertex, thisVertexIndex) => {
			let xDist = Math.abs(thisVertex.x - myCoordinate.x);
	    let yDist = Math.abs(thisVertex.y - myCoordinate.y);
	    let hypDist = Math.hypot(xDist, yDist);
			// if searching for closest vertex with real values
			if (this.currentPinOptions.findClosestValues) {
				if (hypDist < shortestDistance && this.terrainData[thisVertexIndex].binnedIds.length > 0) {
					shortestDistance = hypDist;
					closestVertexIndex = thisVertexIndex;
				}
			}
			// if just searching for closest vertex regardless of value
			else{
				if (hypDist < shortestDistance) {
					shortestDistance = hypDist;
					closestVertexIndex = thisVertexIndex;
				}
			}
		});

		let closestVertex = this.terrainData[closestVertexIndex];

		closestVertex.x = myVertices[closestVertexIndex].x;
		closestVertex.y = myVertices[closestVertexIndex].y;
		closestVertex.z = myVertices[closestVertexIndex].z;

		// return closestVertex.binnedIds;
		return closestVertex;

	},

	_findVertexIndexFromData(projectedId) {

		// Triggered by this.setPin()

		let vertexIndex = null;

		this.terrainData.forEach( (thisVertex, thisVertexIndex) => {
			if (thisVertex.binnedIds.includes(projectedId)) {
				vertexIndex = thisVertexIndex;
			}
		});

		return vertexIndex;

	},

	_findCoordinateFromVertexIndex(vertexIndex) {

		let pinPosition = null;

		let landscape = this.scene.getObjectByName("landscape");
		let vertices = landscape.geometry.vertices;
		pinPosition = vertices[vertexIndex];

		return pinPosition;

	},

	_findCoordinateFromData(projectedId) {

		let vertexIndex = null;
		let pinPosition = null;

		this.terrainData.forEach( (thisVertex, thisVertexIndex) => {
			if (thisVertex.binnedIds.includes(projectedId)) {
				let landscape = this.scene.getObjectByName("landscape");
				let vertices = landscape.geometry.vertices;
				pinPosition = vertices[thisVertexIndex];
			}
		});

		return pinPosition;

	},

	_findBinnedIdsFromIndex(index) {

		let binnedIds = this.terrainData[index].binnedIds;
		return binnedIds;

	},

	pinOptions() {


		const state = this.api.inputState.export();
		const pinOptions = state.pinOptions;


		if (!pinOptions.multiPins) {
			this.clearPins();
		}

		this.currentPinOptions = pinOptions;

	},

  _makeCamera(width, height) {

    const state = this.api.inputState.export();
    const options = state.options;
    const cameraPosition = state.cameraPosition;
    let camera;

    if (options.camera === "perspective") {
      // camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
			 camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
    }

    if (options.camera === "orthographic") {
      let left = width / -16;
      let right = width / 16;
      let top = height / 16;
      let bottom = height / -16;
      let near = -200;
      let far = 500;
      let zoom = 1;
      camera = new THREE.OrthographicCamera( left, right, top, bottom, near, far, zoom );
    }

    camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);

		// setting up position
		let up = {};
		if (cameraPosition.up !== null && cameraPosition.up !== undefined) {
			up = new THREE.Vector3(cameraPosition.up[0],cameraPosition.up[1],cameraPosition.up[2]);
		}
		else {
			up = new THREE.Vector3(0,1,0);
		}
		camera.up = up;

    return camera;

  },

	_addPlane() {

		let layout = this.api.layoutElement,
				state = this.api.inputState.export(),
				terrainOptions = state.terrainOptions;

		let data = this.terrainData;
		let scene = this.scene;

		this.widthSegments = this._calcSegements(data, "xVal");
		this.heightSegments = this._calcSegements(data, "yVal");

		let geometry = new THREE.PlaneGeometry(100, 100, this.widthSegments, this.heightSegments);

	  for (let i = 0, l = geometry.vertices.length; i < l; i++) {
	    geometry.vertices[i].z = data[i].z;
	  }

		// apply smoothing, if requested
		if (terrainOptions.smooth) {
			geometry = this._smoothTerrain(geometry);
		}

		// apply z scalinng, if requested
		if (terrainOptions.scaleZ) {
			geometry = this._scaleTerrain(geometry);
		}

		// colorize by z, if requested
		if (terrainOptions.colorByZ) {
			geometry = this._colorizeTerrain(geometry);
		}

		let colorValue = parseInt ( "0x" + terrainOptions.hexColor, 16 );
		let myColor = new THREE.Color( colorValue );

		let material = new THREE.MeshPhongMaterial({
			color: myColor,
			vertexColors: THREE.VertexColors,
			wireframe: terrainOptions.wireframe,
			side: THREE.DoubleSide
		});

	  let plane = new THREE.Mesh(geometry, material);
		plane.name = "landscape";
	  scene.add(plane);

	},

	_scaleTerrain(geometry) {

		let state = this.api.inputState.export(),
				options = state.terrainOptions;

		let myGeometry = geometry;
		let geoMaxZ = 0.0;
		let scaleFactor = 0.0;

		// Locate the tallest Z value
		myGeometry.vertices.forEach( thisVertex => {
			if (thisVertex.z > geoMaxZ) {
				geoMaxZ = thisVertex.z;
			}
		});

		// If the maximum Z in the data is larger than the maxZ in options,
		// then the scale factor will be the difference between the two divided
		// by the maximum Z in  the data.
		if (geoMaxZ > options.maxZ) {
			scaleFactor = 1 - ((geoMaxZ - options.maxZ) / geoMaxZ);
		}
		else {
			scaleFactor = 1 + ((options.maxZ - geoMaxZ) / geoMaxZ);
		}



		myGeometry.vertices.forEach( thisVertex => {
			thisVertex.z = thisVertex.z * scaleFactor;
			// If logZ is true, apply additional scaling with logZ
			// (a z value of 10/10 = 10/10, 5/10 = 6.9/10)
			if (options.logZ) {
				if (thisVertex.z > 0) {
					thisVertex.z = thisVertex.z * ( Math.log( (thisVertex.z / options.maxZ) * 10) / (Math.log(10)) ) ;
				}
			}
		});

		return myGeometry;

	},

	_colorizeTerrain(geometry) {

		let state = this.api.inputState.export(),
				terrainOptions = state.terrainOptions;

		let vertexIndex, p, color;
		let faceIndices = [ 'a', 'b', 'c' ];
		let radius = 10;

		let widthSegments = geometry.parameters.widthSegments;
		let heightSegments = geometry.parameters.heightSegments;

		// map out faces to vertices
		let faceDirectory = this._mapFaces(widthSegments, heightSegments);

		// colorizing strictly by one color
		if (terrainOptions.colorByZScale === "" || terrainOptions.colorByZScale === null) {
			geometry = this._colorByZ(geometry, faceDirectory);
		}

		// colorizing according to a d3.js color scale
		else {
			geometry = this._colorByZScale(geometry, faceDirectory);
		}

		return geometry;

	},

	_mapFaces(widthSegments, heightSegments) {

		// Terrain can only be colored by coloring the faces directly.
		// Faces can be colored by each of their three vertices.
		// However, the 'geometry' object of the terrain does not match
		// faces to vertices directly. Therefore, this function was built
		// to map those faces to vertices.
		// Each element of facesDirectory array represents one face (faces are drawn
		// from left-right, filling up the back row of the terrain first,
		// then moving forward).
		// Each face has three elements, each an integer indicating the index for the
		// corresponding vertices. Vertices are counted from back-left to front-right
		// as well.

		let faceDirectory = [];
		let i = 0;

		for (let y = 0; y < heightSegments; y++) {
			for (let x = 0; x < (widthSegments * 2); x++) {
				let thisFace = [];
				if (y === 0 && x === 0) {
					thisFace = [ 0, widthSegments + 1, 1 ];
					faceDirectory.push(thisFace);
				}
				if (y === 0 && x === 1) {
					thisFace = [ widthSegments + 1, widthSegments + 2, 1 ];
					faceDirectory.push(thisFace);
				}
				if (y > 0 && x === 0) {
					thisFace.push(faceDirectory[ i - 2 ][0] + 2);
					thisFace.push(faceDirectory[ i - 2 ][1] + 2);
					thisFace.push(faceDirectory[ i - 2 ][2] + 2);
					faceDirectory.push(thisFace);
				}
				if (y > 0 && x === 1) {
					thisFace.push(faceDirectory[ i - 2 ][0] + 2);
					thisFace.push(faceDirectory[ i - 2 ][1] + 2);
					thisFace.push(faceDirectory[ i - 2 ][2] + 2);
					faceDirectory.push(thisFace);
				}
				if (x > 1) {
					thisFace.push(faceDirectory[ i - 2 ][0] + 1);
					thisFace.push(faceDirectory[ i - 2 ][1] + 1);
					thisFace.push(faceDirectory[ i - 2 ][2] + 1);
					faceDirectory.push(thisFace);
				}
				i++;
			}
		}

		return faceDirectory;

	},

	_colorByZ(geometry, faceDirectory) {

		let state = this.api.inputState.export(),
				terrainOptions = state.terrainOptions;

		let hexColor = parseInt( "0x" + terrainOptions.hexColor, 16 );
		let myColor = new THREE.Color( hexColor );
		// change L value to allow more room for z coloring
		let myHSL = myColor.getHSL();
		myColor.setHSL(myHSL.h, myHSL.s, 0.2);

		let allVertices = [];
		let maxZ = 0;
		geometry.vertices.forEach ( (thisVertex) => {
			allVertices.push(thisVertex.z);
			if (thisVertex.z > maxZ) {
				maxZ = thisVertex.z;
			}
		});

		let i = 0;
		let zGradient = ( .8 / maxZ );

		geometry.faces.forEach( (thisFace, faceIndex) => {
			let thisVertexIndex = 0;
			let vertexHeights = [];
			for (let v = 0; v < 3; v++) {
				let newColor = new THREE.Color();
				newColor.setHSL( 0.125, 1.0, .2 );
				thisFace.vertexColors[v] = newColor;
				thisVertexIndex = faceDirectory[faceIndex][v];
				if (allVertices[thisVertexIndex] > 0) {
					newColor.setHSL( 0.125, 1.0, (allVertices[thisVertexIndex] * zGradient) + 0.2);
					thisFace.vertexColors[v] = newColor;
				}
			}
		});

		return geometry;

	},

	_colorByZScale(geometry, faceDirectory) {

		let allVertices = [];
		let maxZ = 0;
		geometry.vertices.forEach ( (thisVertex) => {
			allVertices.push(thisVertex.z);
			if (thisVertex.z > maxZ) {
				maxZ = thisVertex.z;
			}
		});

		let i = 0;
		let zGradient = ( .8 / maxZ );

		geometry.faces.forEach( (thisFace, faceIndex) => {
			let thisVertexIndex = 0;
			let vertexHeights = [];
			for (let v = 0; v < 3; v++) {
				thisVertexIndex = faceDirectory[faceIndex][v];
				let myGradient = allVertices[thisVertexIndex] / maxZ;
				let thisColor = this._applyColorScale(myGradient);
				let newColor = new THREE.Color(thisColor);
				thisFace.vertexColors[v] = newColor;
			}
		});

		return geometry;

	},

	_applyColorScale(myGradient) {

		let state = this.api.inputState.export(),
				options = state.terrainOptions;

		let myColor = {};

		myColor = d3[options.colorByZScale](myGradient);

		return myColor;

	},

	_addThisText( text ) {

		let state = this.api.inputState.export(),
				labelOptions = state.labelOptions;

		let label = text.label;
		let size = text.size;
		let color = text.color;
		let name = text.name;
		let position = text.position;
		let rotation = text.rotation;

		// text.rotation = {x: 0, y: 0, z: 0}

		let _this = this;

		const helvetiker_regular = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/fonts/helvetiker_regular.typeface.json';
		let loader = new THREE.FontLoader();

		loader.load( helvetiker_regular,
			function ( font ) {
				//let myXLabel = labelOptions.xLabel;
				let labelGeom = new THREE.TextGeometry( label, {
						font: font,
						size: size,
						height: 0,
						curveSegments: 12,
						bevelSize: 8,
						bevelSegments: 5
				});
				let labelGeomMaterial = new THREE.MeshPhongMaterial(
    			{
						color: color,
						specular: 0xffffff }
  			);
				let myLabel = new THREE.Mesh( labelGeom, labelGeomMaterial );
				myLabel.name = name;
				myLabel.position.set( position.x, position.y, position.z );
				if (text.rotation !== null) {
					myLabel.rotation.x = rotation.x;
					myLabel.rotation.y = rotation.y;
					myLabel.rotation.z = rotation.z;
				}
				_this.scene.add( myLabel );
			}
		);

	},

	_addAxesLabels() {

		let state = this.api.inputState.export(),
				labelOptions = state.labelOptions;

		let myXLabel = labelOptions.xLabel;
		if (myXLabel !== "") {
			let text = {
					label: myXLabel,
					size: 4,
					color: 0xff0000,
					name: "x_axis_label",
					position: {
							x: labelOptions.xLabelPosition[0],
							y: labelOptions.xLabelPosition[1],
							z: labelOptions.xLabelPosition[2]
						},
					rotation: {
							x: labelOptions.xLabelRotation[0] * (Math.PI/180),
							y: labelOptions.xLabelRotation[1] * (Math.PI/180),
							z: labelOptions.xLabelRotation[2] * (Math.PI/180)
						},
				};
			this._addThisText( text );
		}

		let myYLabel = labelOptions.yLabel;
		if (myYLabel !== "") {
			let text = {
					label: myYLabel,
					size: 4,
					color: 0x00ff00,
					name: "y_axis_label",
					position: {
							x: labelOptions.yLabelPosition[0],
							y: labelOptions.yLabelPosition[1],
							z: labelOptions.yLabelPosition[2]
						},
					rotation: {
							x: labelOptions.yLabelRotation[0] * (Math.PI/180),
							y: labelOptions.yLabelRotation[1] * (Math.PI/180),
							z: labelOptions.yLabelRotation[2] * (Math.PI/180)
						},
				};
			this._addThisText( text );
		}

		let myZLabel = labelOptions.zLabel;
		if (labelOptions.zLabel !== "") {
			let text = {
					label: myZLabel,
					size: 4,
					color: 0x0000ff,
					name: "z_axis_label",
					position: {
							x: labelOptions.zLabelPosition[0],
							y: labelOptions.zLabelPosition[1],
							z: labelOptions.zLabelPosition[2]
						},
					rotation: {
							x: labelOptions.zLabelRotation[0] * (Math.PI/180),
							y: labelOptions.zLabelRotation[1] * (Math.PI/180),
							z: labelOptions.zLabelRotation[2] * (Math.PI/180)
						},
				};
			this._addThisText( text );
		}

	},

	_addValueLabels() {

		let layout = this.api.layoutElement,
				state = this.api.inputState.export(),
				labelOptions = state.labelOptions;

		let scene = this.scene;

		let myXValues = labelOptions.xValues;
		let xValueDivision = 100 / myXValues.length;
		let myYValues = labelOptions.yValues;
		let yValueDivision = 100 / myYValues.length;

		myXValues.forEach( (thisXValue, pos) => {
			let thisXPos = (pos * xValueDivision) + (xValueDivision * 0.5) + labelOptions.xValuesPosition[0];
			let text = {
				label: thisXValue,
				size: 3,
				color: 0x000000,
				name: "x_value_label",
				position: {
						x: thisXPos,
						y: labelOptions.xValuesPosition[1],
						z: labelOptions.xValuesPosition[2],
					},
				rotation: {
						x: labelOptions.xValuesRotation[0] * (Math.PI/180),
						y: labelOptions.xValuesRotation[1] * (Math.PI/180),
						z: labelOptions.xValuesRotation[2] * (Math.PI/180)
					},
			};
			this._addThisText( text );
		});

		myYValues.forEach( (thisYValue, pos) => {
			let thisYPos = (pos * yValueDivision) + (yValueDivision * 0.5) + labelOptions.yValuesPosition[1];
			let text = {
				label: thisYValue,
				size: 3,
				color: 0x000000,
				name: "y_value_label",
				position: {
					x: labelOptions.yValuesPosition[0],
					y: thisYPos,
					z: labelOptions.yValuesPosition[2],
				},
				rotation: {
						x: labelOptions.yValuesRotation[0] * (Math.PI/180),
						y: labelOptions.yValuesRotation[1] * (Math.PI/180),
						z: labelOptions.yValuesRotation[2] * (Math.PI/180)
					},
			};
			this._addThisText( text );
		});

	},

	_drawOutline() {

		let scene = this.scene;

		let geometry = new THREE.PlaneGeometry(126, 114, 1, 1);

		let material = new THREE.MeshPhongMaterial({
			color: 0x000000,
			vertexColors: THREE.VertexColors,
			side: THREE.DoubleSide
		});

	  let outline = new THREE.Mesh(geometry, material);

		outline.name = "outline";
		outline.position.x = -13;
		outline.position.y = -7;
		outline.position.z = -1;

	  scene.add(outline);

	},

	_calcSegements(data, prop) {

		let uniqueSegments = new Set();

		data.forEach( thisPoint => {
			uniqueSegments.add(thisPoint[prop]);
		});

		return (uniqueSegments.size - 1) ;

	},

	_makeTerrainData() {

		this.terrainData = [];

		let state = this.api.inputState.export();
    let points = state.data.points;
    let options = state.terrainOptions;

    // RESOLUTION = number of lines

    const xBins = options.resolution;
    const yBins = options.resolution;

    // contains cut-offs for binning

    let xBinLim = [];
    let yBinLim = [];

    let minX = 0;
    let maxX = 0;
    let minY = 0;
    let maxY = 0;
    let minZ = 0;
    let maxZ = 0;

    // find min and max of each dimension

    points.forEach( thisPoint => {
      if (thisPoint.x < minX) { minX = thisPoint.x; }
      if (thisPoint.x > maxX) { maxX = thisPoint.x; }
      if (thisPoint.y < minY) { minY = thisPoint.y; }
      if (thisPoint.y > maxY) { maxY = thisPoint.y; }
      if (thisPoint.z < minZ) { minZ = thisPoint.z; }
      if (thisPoint.z > maxZ) { maxZ = thisPoint.z; }
    });

		this.maxZ = maxZ;
		this.minZ = minZ;

    xBinLim.push(minX);
    yBinLim.push(minY);

    // find bin size for x and y dimension

    let binSizeX = (maxX - minX) / (xBins - 1);
    let binSizeY = (maxY - minY) / (yBins - 1);

    for (let i = 1; i < xBins; i++) {
      xBinLim.push( xBinLim[i - 1] + binSizeX );
    }

		// If there is a border specified in terrainOptions.borderWidth,
		// shift the grid accordingly and allow room for two new rows and two new columns
		// all points within these columns will have zero height
		// a 5 x 5 grid (25pts) becomes a 7 x 7 grid (49pts)

		if (options.borderWidth) {
			// adding x bins before real data
			for (let a = 1; a <= options.borderWidth; a++) {
				xBinLim.unshift( xBinLim[0] + (binSizeX * a * -1) );
			}
			// adding x bins after real data
			for (let b = 1; b <= options.borderWidth; b++) {
				xBinLim.push( xBinLim[xBinLim.length - 1] + (binSizeX * b) );
			}
		}

		// xBinLim must be reversed, because three.js starts drawing points from back to front
		xBinLim = xBinLim.reverse();

    for (let i = 1; i < yBins; i++) {
      yBinLim.push( yBinLim[i - 1] + binSizeY );
    }

		if (options.borderWidth) {
			// adding y bins before real data
			for (let a = 1; a <= options.borderWidth; a++) {
				yBinLim.unshift( yBinLim[0] + (binSizeY * a * -1) );
			}
			// adding y bins after real data
			for (let b = 1; b <= options.borderWidth; b++) {
				yBinLim.push( yBinLim[yBinLim.length - 1] + (binSizeY * b) );
			}
		}

    let totalPoints = 0;

    // now each entity/point must be defined
		// left to right, back to front

    xBinLim.forEach( thisXBin => {
      yBinLim.forEach( thisYBin => {
        let thisPoint = {};
        thisPoint.xVal = thisXBin;
        thisPoint.yVal = thisYBin;
        thisPoint.n = 0;
        thisPoint.sum = 0;
				thisPoint.binnedIds = [];
        points.forEach( dataPoint => {
          if (dataPoint.x >= thisXBin && dataPoint.x < (thisXBin + binSizeX) && dataPoint.y >= thisYBin && dataPoint.y < (thisYBin + binSizeY)) {
            totalPoints++;
            thisPoint.n += 1;
            thisPoint.sum += dataPoint.z;
						thisPoint.binnedIds.push(dataPoint.projectedId);
          }
        });
        this.terrainData.push(thisPoint);
      });
    });

    // now the average for each data bin must be computed
    this.terrainData.forEach( thisBin => {
      if (thisBin.n) {
				thisBin.z = thisBin.sum / thisBin.n;
      }
      else {
        thisBin.z = 0;
      }
    });

    this.api.output("terrainData", this.terrainData);

	},

	_smoothTerrain(geometry) {

		let state = this.api.inputState.export();
    let options = state.terrainOptions;
		let myTerrain = this.terrainData;

		// creates a list of neighboring verticies
		// that should be changed to accomodate smoothing
		let allNeighbors = [];

		// First, enforce a permiter, as we can't make assumptions about
		// data that may exist beyond the terrain. Points on the perimeter
		// would be improperly weighted if perimeter not enforced.
		// Perimeter is the same size as the smoothing radius.
		// All vertices in thins perimeter ar to be set to 0 height.

		if (options.bestFitSmooth) {
			geometry = this._enforcePerimeter(geometry, options.smooth);
		}

		// Now that perimeter has been enforced, search for all vertices which
		// have some height.
		// Then, find the neighbors for each of those vertices.

		geometry.vertices.forEach( (thisVertex, vertexIndex) => {
			let theseNeighbors = [];
			if (thisVertex.z > 0) {
				let thisHeight = thisVertex.z;
				// identify all points within a specified radius, by index
				theseNeighbors = this._findAdjacent(thisVertex, geometry);
			}
			// If the _findAdjacent fx returns neighbors,
			// append those neighbors to the list of all neighbors.
			if (theseNeighbors.length) {
				allNeighbors = allNeighbors.concat(theseNeighbors);
			}
		});

		// Remove from the list of neighbors
		// vertices that are part of the border
		if (options.borderWidth) {
			allNeighbors = this._removeBorderVertices(allNeighbors, geometry);
		}

		// What about neighbors that are shared between vertices?
		// Eliminate duplicate vertices by averaging the common values.
		if (options.bestFitSmooth) {
			allNeighbors = this._averageNeighbors(allNeighbors);
		}

		// If using best fit smooth, neighbors values will always change.
		if (options.bestFitSmooth) {
			allNeighbors.forEach( thisNeighbor => {
				geometry.vertices[thisNeighbor.index].z = thisNeighbor.z;
				// geometry.vertices[thisNeighbor.index].z = neighborsAvg * Math.cos(Math.PI * (thisNeighbor.distance / myRadius));
			});
		}

		// If not using best fit smooth, only change if resulting z is greater than current z.
		else {
			allNeighbors.forEach( thisNeighbor => {
				if (geometry.vertices[thisNeighbor.index].z < thisNeighbor.z) {
					geometry.vertices[thisNeighbor.index].z = thisNeighbor.z;
				}
			});
		}

		return geometry;

	},

	_removeBorderVertices(allNeighbors, geometry) {

		let state = this.api.inputState.export();
    let options = state.terrainOptions;

		// First identify which vertices in the geometry are border vertices
		// vertices are found in geometry.vertices
		// verticies are indexed from back-left, to right, then forward.

		let borderVertices = [];
		let borderWidth = options.borderWidth;
		let planeSegments = this.widthSegments + 1;
		let row = 1;
		let column = 1;

		// the first x columns
		// and the last x columns
		// where x is the border width

		geometry.vertices.forEach( (thisVertex, thisVertexIndex) => {

			// Border verticies will be the first x rows and the last x rows
			if (row <= borderWidth || row >= (planeSegments - borderWidth)) {
				borderVertices.push(thisVertexIndex);
			}

			else {

				// and the first x columns and the last x columns
				if(column <= borderWidth || column >= (planeSegments - borderWidth)) {
					borderVertices.push(thisVertexIndex);
				}

			}

			// increment the columns and rows
			if (column >= planeSegments) {
				column = 1;
				row++;
			}
			else {
				column++;
			}

		});

		let newNeighbors = [];

		allNeighbors.forEach( thisNeighbor => {
			if ( !borderVertices.includes(thisNeighbor.index) ) {
				newNeighbors.push(thisNeighbor);
			}
		});

		return newNeighbors;

	},

	_enforcePerimeter(geometry, smoothingRadius) {

		let myRadius = 100 / (geometry.parameters.widthSegments + 1);
		myRadius = myRadius * smoothingRadius;

		geometry.vertices.forEach( vertex => {
			if (vertex.x < (-50 + myRadius) || vertex.x > (50 - myRadius)) {
				vertex.z = 0;
			}
			if (vertex.y < (-50 + myRadius) || vertex.y > (50 - myRadius)) {
				vertex.z = 0;
			}
		});

		return geometry;

	},

	_findAdjacent(myVertex, geometry) {

		// takes a single vertex and the landscape geometry
		// returns a duffle of neighboring vertices
		// with their index and height adjustment

		let state = this.api.inputState.export();
    let options = state.terrainOptions;

		let myRadius = 100 / (geometry.parameters.widthSegments + 1);
		myRadius = myRadius * options.smooth;

		let myNeighbors = [];

		geometry.vertices.forEach( (vertex, vertexIndex) => {
			let thisNeighbor = {};
			let xDist = Math.abs(vertex.x - myVertex.x);
			let yDist = Math.abs(vertex.y - myVertex.y);
			let hypDist = Math.hypot(xDist, yDist);
			if (hypDist < myRadius) {
				thisNeighbor.index = vertexIndex;
				thisNeighbor.distance = hypDist;
				if (options.bestFitSmooth) {
					thisNeighbor.z = vertex.z;
				}
				else {
					thisNeighbor.z = myVertex.z * Math.cos((Math.PI/2) * (hypDist / myRadius));
				}
				myNeighbors.push(thisNeighbor);
			}
		});

		// Average all the vertices in this local group
		// only do this if bestFitSmooth is true
		let neighborsSum = 0;
		let neighborsAvg = 0.0;
		if (options.bestFitSmooth) {
			myNeighbors.forEach( thisNeighbor => {
				neighborsSum += thisNeighbor.z;
			});
			neighborsAvg = neighborsSum / myNeighbors.length;
			myNeighbors.forEach( thisNeighbor => {
				thisNeighbor.z = neighborsAvg * Math.cos((Math.PI/2) * (thisNeighbor.distance / myRadius));
			});
		}

		return myNeighbors;

	},

	_averageNeighbors(allNeighbors) {

		// Average the height of vertices who are neighbors to more than one vertex.

		let neighborIndecies = [];

		// create an array with just the indices of single vertices
		allNeighbors.forEach( thisNeighbor => {
			if (!neighborIndecies.includes(thisNeighbor.index)) {
				neighborIndecies.push(thisNeighbor.index);
			}
		});

		// now that we have array of just matching indices, search among those indices.
		// sum all the z values for each of those indices.
		let finalNeighbors = [];
		let duplicatesFound = 0;
		neighborIndecies.forEach( thisIndex => {
			let myNeighbor = {};
			let zSum = 0;
			let dSum = 0;
			let indexCount = 0;
			allNeighbors.forEach( thisNeighbor => {
				if (thisNeighbor.index === thisIndex) {
					// indices match, add to sum
					zSum += thisNeighbor.z;
					dSum += thisNeighbor.distance;
					indexCount++;
				}
			});
			// after all neighbors have been searched, finish averaging.
			myNeighbor.index = thisIndex;
			myNeighbor.distance = dSum / indexCount;
			myNeighbor.z = zSum / indexCount;
			finalNeighbors.push(myNeighbor);
			duplicatesFound += indexCount;
		});

		return finalNeighbors;

	}

};
